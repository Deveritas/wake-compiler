import "balloon";
import(js) "poop";
import(java) "lalala";

every BigBanana (a Banana, capable Pillow, capable Shitzu) is:
	provides
		Monkey,
		Mammal <- Squirrel,
		Mammal <- { return ; },
		Mammal{Sea} <- SeaOtter,
		Picture <- Picture{Cracked},
		Picture{Cracked} <- Picture("Cracked"),
		Picture{Cracked} <- Picture("Cracked\n\n\n\tnewlines then tab then \\ backslash then \ backslash"),
		Europe{Medieval} <- Europe(1057),
		LotsOfArgs{Test} <- ManyArgs(Europe{Medieval}, Picture{Cracked}, ???);

	needs
		Pillow,
		beec{Important} @c,
		$pillow,
		$$$pillow
	then {
		(5 * (5 + 5) / 33 < 44 == 3) ? 44 : 22 + 5;
		while(false && true || 789) 5 + 5.toThe(@x)thPower();
		@var MyType <- Provider;
		@var OtherType -- fn(MyType) <- @MyOtherType;
		while(33 / ATunnel + 1) {
			it.eatMyPants(); it / 55;
		}
		return;
		return @var;
		continue;
		break;
	}

	Text -- getName() {
		Me.Text;
		Me.Text();
		Me.Text().Property; Me.Fnc().@Text; Me.Fnc().@Text[2]; Me.Fnc().$Property[]; Me.Fnc().$Property[2];
		Me.Text(Architect)ForName();
		Me.Text(Architect)ForName().Text;
		Me.Text(Architect)ForName()[3 + 55].Text;
		return getName();
		return getName(8)FromArgs(MyStuff);
		return getName(TestTest)FromArgs(MyStuff)AndEndingLike();
	}

	Text -- getName( Int @forsomereason, Pillow, @this Thing, $Duck, $$$$Duck )FromThis() {
		if(@forsomereason && Pillow) return "blah";
	}

	fn( Text, Blueberry ) -- getFunction( Bob @thebuilder )With( Text @a )too() {
		switch(@thebuilder) {
			case 2: return Blueberry[];
			default: return 9 + 5 / 33;
		}
	}

	fn(Text) -- fn( Int, Pillow, Thing ) -- getFunction( Bob @thebuilder )With( Text @a )too() {
		return (((Bob) / 3) + 4) * 99999.max(4) + "abcdefg".length;
	}
